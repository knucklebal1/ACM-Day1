# ACM-Day1
1. long loong
·思路：
1）先设置一个字符串s存放第一个字符L
2）由于字符o的数量由输入的数字N的值决定，因此想到用for循环语句进行重复多次输出o，将这些o加到字符串s里。
3）输出添加o后的字符串s，在后面补上剩下的两个字符ng
·总结：
用for循环实现字符的重复输出
2. YES or YES
·思路：
1）把输入的字符串通过头文件algorithm中transform算法全部转为大写格式
2）将转换后的输入字符串与YES比较：如果相同，输出YES；如果不同，输出N（使用if else语句判断）
·总结：
出现大小写不限的字符串内容比较时，可以将二者用transform统一化为大写或小写，再进行比较
3. Even? Odd? G
·思路：
1）由于输入值的范围较大（超出int的范围），因此选择创建一个字符数组来存放输入值，最大输入值的位数即为数组的大小
2）通过for循环语句读取输入值并存在字符数组里，
3）因为输入值可能较大，而偶数的特点是个位数为偶数（0,2,4,6,8），所以取字符数组的最后一个字符，用ASCII码的原理，将该字符减去‘0’，获得该字符实际代表的数值，%2判断余数是否为0（为0，偶数；反之，奇数）
·总结：
遇到较大输入值时，考虑将其转为字符数组存放（输入值的位数即为数组的大小）；通过判断个位数的性质来确定奇偶数；将字符数字与字符‘0’相减，可以获得该字符数字的实际数值（ASCII码原理）
4. Problem Generator
·思路：
1）用字符数组a存放已想到的题目
2）再设一个字符数组grade存放应出题目的等级（A~G）作为对照
3）遍历grade，将每一个等级与a比对，用count算法统计每一个等级在a中出现的次数c（用for循环语句）
4）把每个等级对应的次数c与比赛轮次比较：如果发现c<m，意味着该等级题目不够，通过m-c得出还需要出的题数
5）将不同等级还差的题数累加到空整型min里
·总结：
通过建立额外的数组（标准数组）与原数组比对，可以统计出原数组中某些元素出现的次数（先用for循环遍历标准数组，再用count算法将原数组与标准数组中的元素比对、统计次数）
5. rules
·思路：
1）先用嵌套循环读取并存储考察期内居民遵守的规则代码rule
2）将rule与考察规则的代码k比较（if语句），如果rule=k，说明该居民遵守了考察规则，统计到空整型obey里（obey+1），记录完一天后，跳出该层for循环，obey重置
3）将统计的遵守人数obey与居民总人数n比较（if语句），若obey大于n的一半，说明该规则这天是合民意的，统计到空整型c（c+1）
4）跳出所有for循环，将c与考察天数m比较，若c大于m的一半（if语句），说明该规则正确，输出YES；反之输出NO
·总结：
通过嵌套循环录入多个有分组的数据；判断a是否大于b的一半，可用a>=b/2+(b%2)，或a>=(b+1)/2
6. Many Replacement
·思路：
1）用vector创建一个动态字符对数组operations读取所有的操作并存储，operations的大小为操作次数Q
2）再设一个映射finalChanges合并操作：外层用一个for循环分离出operations中的每一步操作op，与finalChanges比对；内层先用for循环遍历所有字符，将需要修改的字符更新为最终目标，若当前字符没有被修改过，直接更新（另一个if语句）
3）最后遍历字符串S进行修改
·总结：
若要节省时间，考虑用空间换时间；运用映射让操作中的c和d产生联系，并进行合并，如[a→r, r→m]可合并为[a→m]
7. 更好的交换
·思路：
1）因为交换整行或整列的操作太耗费空间，所以转变思路，交换行或列的标号
2）设tagx和tagy两个数组分别读取并储存矩阵的行标和列标
3）再用swap算法进行行标或列标的对换
4）最后设一个新的矩阵来将打乱后的行标和列标重新排序，以此达到对换了一整行或一整列的操作
·总结：
用空间换时间，若矩阵较大，可以考虑对其的行标和列标进行操作，以此来达到对相应位置元素进行操作的目的
